---
title: CCJK 六阶段工作流
---

# CCJK 六阶段工作流

六阶段工作流是 CCJK 的核心开发流程，涵盖完整的软件开发生命周期：**研究 → 构思 → 计划 → 执行 → 优化 → 评审**。

## 功能特点

- 📊 **结构化流程**：每个阶段都有明确的输入/输出与 AI 行为规范
- ✅ **强制确认机制**：每个阶段完成后需要用户确认，避免遗漏用户反馈
- 📝 **自动文档生成**：自动生成计划文档并要求保存在项目目录
- 🔄 **迭代支持**：支持多轮迭代和持续改进

## 使用方法

### Claude Code

在 Claude Code 中使用以下命令：

```
/ccjk:workflow <任务描述>
```

**示例**：
```
/ccjk:workflow 实现用户登录功能，支持邮箱和手机号登录
```

### Codex

在 Codex 中使用以下命令（注意前缀不同）：

```
/prompts:workflow <任务描述>
```

**示例**：
```
/prompts:workflow 实现用户登录功能，支持邮箱和手机号登录
```

> 💡 **提示**：Codex 使用 `/prompts:` 前缀，而 Claude Code 使用 `/ccjk:` 前缀。

## 六阶段详解

### 1. 研究（Research）

**目标**：深入理解任务需求和背景

**AI 行为**：
- 分析任务描述和上下文
- 收集相关技术资料和最佳实践
- 识别潜在问题和风险点
- 理解用户需求和业务场景

**输出**：
- 需求分析报告
- 技术调研结果
- 风险评估

### 2. 构思（Ideate）

**目标**：生成多个可行的解决方案

**AI 行为**：
- 提出多个设计方案
- 评估各方案的优缺点
- 考虑技术可行性和实现复杂度
- 推荐最佳方案

**输出**：
- 多个设计方案
- 方案对比分析
- 推荐方案及理由

### 3. 计划（Plan）

**目标**：制定详细的实施计划

**AI 行为**：
- 将任务拆解为具体步骤
- 确定技术选型和架构设计
- 制定时间估算和里程碑
- 识别依赖关系和前置条件

**输出**：
- 详细的任务分解
- 技术实现方案
- 开发计划和时间线
- 计划文档（保存在 `.ccjk/plan/current/任务名.md`）

### 4. 执行（Execute）

**目标**：按照计划实施开发

**AI 行为**：
- 按照计划逐步实现功能
- 编写代码和测试用例
- 处理实现过程中的问题
- 保持代码质量和规范

**输出**：
- 实现的代码
- 测试用例
- 相关文档

### 5. 优化（Optimize）

**目标**：提升代码质量和性能

**AI 行为**：
- 代码重构和优化
- 性能优化建议
- 安全性检查
- 代码规范审查

**输出**：
- 优化后的代码
- 性能改进建议
- 安全审查报告

### 6. 评审（Review）

**目标**：最终评估和总结

**AI 行为**：
- 全面审查实现结果
- 生成测试报告
- 总结经验和教训
- 提出后续改进建议

**输出**：
- 完整的实现总结
- 测试报告
- 经验总结
- 改进建议

## 执行流程

### 基本流程

1. **输入命令**：输入 `/ccjk:workflow` 或 `/prompts:workflow` 并描述任务
2. **阶段执行**：AI 按顺序执行六个阶段
3. **用户确认**：每个阶段完成后等待用户确认
4. **继续下一步**：用户确认后进入下一阶段
5. **文档保存**：计划文档自动保存到项目目录

### 文档保存位置

工作流会自动生成计划文档并要求保存：

- **进行中的任务**：`.ccjk/plan/current/` 目录
- **已完成的任务**：`.ccjk/plan/history/` 目录

> 💡 **提示**：`.ccjk/` 是统一的工作流目录，无论使用 Claude Code 还是 Codex 都使用相同的路径。

#### 文件命名规则

- **进行中**：`任务名.md`（例如：`用户登录功能.md`）
- **归档后**：`[完成时间]任务名.md`（例如：`2024-01-15_143052用户登录功能.md`）

时间格式为 `YYYY-MM-DD_HHMMSS`，通过 bash 命令自动获取以确保准确性。

## 最佳实践

### 1. 任务拆分

对于复杂任务，建议先拆分再分别执行：

```
# 主任务
/ccjk:workflow 构建用户管理系统

# 子任务 1
/ccjk:workflow 实现用户注册功能

# 子任务 2
/ccjk:workflow 实现用户登录功能

# 子任务 3
/ccjk:workflow 实现用户信息管理
```

### 2. 结合项目初始化

在开始工作流前，建议先初始化项目配置：

```
# 1. 初始化项目（Claude Code）
/init-project

# 2. 或初始化项目（Codex）
# Codex 暂不支持 init-project，可直接使用工作流

# 3. 执行工作流
/ccjk:workflow <任务描述>
```

初始化后会生成：
- **Claude Code**：`CLAUDE.md` 项目配置文档
- **Codex**：`AGENTS.md` 代理配置文档

这些文档为工作流提供项目上下文。

### 3. 利用计划文档

工作流生成的计划文档可以：

- 📖 **参考和回顾**：在后续开发中参考计划文档
- 🔄 **迭代更新**：根据实际情况更新计划
- 👥 **团队协作**：与团队成员分享计划
- 📝 **文档归档**：纳入版本控制作为项目文档

### 4. 阶段确认技巧

在每个阶段确认时，可以：

- ✅ **快速通过**：如果结果满意，直接确认进入下一阶段
- 🔄 **要求调整**：如果不满意，要求 AI 调整后再确认
- 📝 **添加要求**：在确认时添加额外的要求或约束
- ⏸️ **暂停保存**：在关键阶段暂停，保存中间结果

### 5. 与其他工作流结合

六阶段工作流可以与其他工作流结合使用：

```bash
# 1. 使用功能开发工作流规划功能
/ccjk:feat 用户评论功能

# 2. 使用六阶段工作流实现细节
/ccjk:workflow 实现评论的 CRUD 操作和权限控制

# 3. 使用 Git 工作流提交代码
/git-commit
```

## 使用示例

### 示例 1：简单功能开发

```
/ccjk:workflow 添加用户头像上传功能
```

工作流会：
1. 研究头像上传的最佳实践
2. 构思多种实现方案（本地存储 vs 云存储）
3. 制定详细的实现计划
4. 实现上传功能和预览
5. 优化图片压缩和缓存
6. 评审完整功能

### 示例 2：复杂系统开发

```
/ccjk:workflow 构建微服务架构的用户认证系统，支持 OAuth2 和 JWT
```

工作流会：
1. 深入研究微服务认证架构
2. 设计 OAuth2 和 JWT 集成方案
3. 制定详细的架构和实施计划
4. 逐步实现各个组件
5. 优化性能和安全性
6. 全面评审系统

### 示例 3：代码重构

```
/ccjk:workflow 重构用户模块，提升代码质量和可维护性
```

工作流会：
1. 分析现有代码结构和问题
2. 设计重构方案
3. 制定渐进式重构计划
4. 逐步重构代码
5. 优化代码结构
6. 验证重构效果

## 注意事项

### 计划文档位置

工作流使用统一的 `.ccjk/plan/` 目录结构：

```
项目根目录/
└── .ccjk/
    └── plan/
        ├── current/                     # 当前进行中的任务
        │   └── 任务名.md                # 执行计划和上下文
        └── history/                     # 已完成的历史任务
            └── [完成时间]任务名.md      # 归档的任务记录
```

- ⚠️ **统一目录**：无论使用 Claude Code 还是 Codex，都使用 `.ccjk/plan/` 目录
- ✅ **版本控制**：建议将计划文档纳入 Git 版本控制
- 📁 **自动归档**：任务完成后，计划文件自动从 `current/` 移动到 `history/`

### 阶段跳过

不建议跳过阶段确认，因为：

- 每个阶段都有其重要性
- 用户反馈可以帮助 AI 调整方向
- 跳过可能导致遗漏重要步骤

### 长时间任务

对于非常复杂的任务：

- 可以分多次执行工作流
- 每次专注于一个子任务
- 使用计划文档作为衔接

## 相关资源

- [功能开发工作流](feat.md) - 新功能设计与实现
- [BMad 敏捷流程](bmad.md) - 企业级敏捷开发
- [Git 智能命令](git-commands.md) - Git 操作自动化
- [工作流系统](../features/workflows.md) - 工作流详细介绍

> 💡 **提示**：六阶段工作流是 CCJK 的核心功能，适合大多数开发任务。建议先从小任务开始熟悉流程，然后逐步应用到更复杂的项目中。合理利用阶段确认机制，可以获得更好的开发体验。