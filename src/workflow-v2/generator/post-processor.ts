/**
 * Post-Processor for AI-Generated Workflows
 *
 * This module processes, validates, and optimizes workflows
 * generated by the AI to ensure quality and correctness.
 */

import type {
  PostProcessorConfig,
  ProjectContext,
  ValidationError,
  ValidationResult,
  ValidationWarning,
  Workflow,
  WorkflowStep,
} from '../types.js'

export class PostProcessor {
  private config: PostProcessorConfig

  constructor(config: PostProcessorConfig = {}) {
    this.config = {
      validateOutput: config.validateOutput !== false,
      formatOutput: config.formatOutput !== false,
      optimizeOutput: config.optimizeOutput !== false,
      generateTests: config.generateTests || false,
      maxIterations: config.maxIterations || 3,
    }
  }

  /**
   * Process a generated workflow
   */
  async process(workflow: Workflow, context: ProjectContext): Promise<Workflow> {
    let processedWorkflow = workflow

    // Format the workflow
    if (this.config.formatOutput) {
      processedWorkflow = this.format(processedWorkflow)
    }

    // Validate the workflow
    if (this.config.validateOutput) {
      const validation = this.validate(processedWorkflow, context)

      if (!validation.isValid) {
        // Attempt to fix validation errors
        processedWorkflow = await this.fixValidationErrors(
          processedWorkflow,
          validation,
          context,
        )
      }
    }

    // Optimize the workflow
    if (this.config.optimizeOutput) {
      processedWorkflow = this.optimize(processedWorkflow)
    }

    return processedWorkflow
  }

  /**
   * Format workflow for consistency
   */
  private format(workflow: Workflow): Workflow {
    const formatted: Workflow = {
      ...workflow,
      id: workflow.id || this.generateId('workflow'),
      name: workflow.name.trim(),
      description: workflow.description.trim(),
      version: workflow.version || '1.0.0',
      tags: Array.from(new Set(workflow.tags.map(t => t.toLowerCase().trim()))),
      steps: workflow.steps.map(step => this.formatStep(step)),
      metadata: {
        ...workflow.metadata,
        createdAt: workflow.metadata.createdAt || new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        generatedBy: workflow.metadata.generatedBy || 'ai',
        complexity: this.calculateComplexity(workflow),
      },
      requirements: {
        ...workflow.requirements,
        tools: workflow.requirements?.tools || [],
        platforms: workflow.requirements?.platforms || [],
      },
    }

    return formatted
  }

  /**
   * Format a workflow step
   */
  private formatStep(step: WorkflowStep): WorkflowStep {
    return {
      ...step,
      id: step.id || this.generateId('step'),
      name: step.name.trim(),
      description: step.description.trim(),
      command: step.command?.trim(),
      script: step.script?.trim(),
      dependencies: step.dependencies || [],
      timeout: step.timeout || 300,
      validation: step.validation || this.getDefaultValidation(step),
      errorHandling: step.errorHandling || this.getDefaultErrorHandling(),
    }
  }

  /**
   * Validate workflow
   */
  validate(workflow: Workflow, context: ProjectContext): ValidationResult {
    const errors: ValidationError[] = []
    const warnings: ValidationWarning[] = []

    // Check for required fields
    if (!workflow.id) {
      errors.push({
        type: 'syntax_error',
        message: 'Workflow missing required field: id',
        severity: 'critical',
      })
    }

    if (!workflow.name) {
      errors.push({
        type: 'syntax_error',
        message: 'Workflow missing required field: name',
        severity: 'critical',
      })
    }

    if (!workflow.steps || workflow.steps.length === 0) {
      errors.push({
        type: 'syntax_error',
        message: 'Workflow must have at least one step',
        severity: 'critical',
      })
    }

    // Validate steps
    if (workflow.steps) {
      for (const step of workflow.steps) {
        const stepErrors = this.validateStep(step, workflow, context)
        errors.push(...stepErrors)
      }
    }

    // Check for circular dependencies
    const circularDeps = this.detectCircularDependencies(workflow)
    if (circularDeps.length > 0) {
      for (const cycle of circularDeps) {
        errors.push({
          type: 'circular_dependency',
          message: `Circular dependency detected: ${cycle.join(' -> ')}`,
          severity: 'critical',
        })
      }
    }

    // Check for missing dependencies
    const missingDeps = this.detectMissingDependencies(workflow)
    for (const dep of missingDeps) {
      errors.push({
        type: 'missing_dependency',
        stepId: dep.stepId,
        message: `Step references non-existent dependency: ${dep.dependency}`,
        severity: 'high',
      })
    }

    // Generate warnings
    if (workflow.steps) {
      for (const step of workflow.steps) {
        if (step.timeout && step.timeout > 600) {
          warnings.push({
            type: 'long_duration',
            stepId: step.id,
            message: `Step has a very long timeout (${step.timeout}s)`,
          })
        }

        if (step.command && !this.isValidCommand(step.command, context)) {
          warnings.push({
            type: 'invalid_command',
            stepId: step.id,
            message: `Command may not be valid: ${step.command}`,
            suggestion: 'Verify the command exists on the target platform',
          })
        }
      }
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    }
  }

  /**
   * Validate a single step
   */
  private validateStep(
    step: WorkflowStep,
    _workflow: Workflow,
    _context: ProjectContext,
  ): ValidationError[] {
    const errors: ValidationError[] = []

    if (!step.id) {
      errors.push({
        type: 'syntax_error',
        message: 'Step missing required field: id',
        severity: 'critical',
      })
    }

    if (!step.name) {
      errors.push({
        type: 'syntax_error',
        stepId: step.id,
        message: 'Step missing required field: name',
        severity: 'critical',
      })
    }

    if (!step.command && !step.script) {
      errors.push({
        type: 'syntax_error',
        stepId: step.id,
        message: 'Step must have either a command or script',
        severity: 'high',
      })
    }

    if (step.command && !this.isSafeCommand(step.command)) {
      errors.push({
        type: 'syntax_error',
        stepId: step.id,
        message: 'Step contains potentially unsafe command',
        severity: 'high',
      })
    }

    return errors
  }

  /**
   * Detect circular dependencies
   */
  private detectCircularDependencies(workflow: Workflow): string[][] {
    const cycles: string[][] = []
    const visited = new Set<string>()
    const recursionStack = new Set<string>()

    const stepMap = new Map(workflow.steps.map(s => [s.id, s]))

    const dfs = (stepId: string, path: string[]): void => {
      if (recursionStack.has(stepId)) {
        const cycleStart = path.indexOf(stepId)
        cycles.push([...path.slice(cycleStart), stepId])
        return
      }

      if (visited.has(stepId)) {
        return
      }

      visited.add(stepId)
      recursionStack.add(stepId)

      const step = stepMap.get(stepId)
      if (step?.dependencies) {
        for (const dep of step.dependencies) {
          dfs(dep, [...path, stepId])
        }
      }

      recursionStack.delete(stepId)
    }

    for (const step of workflow.steps) {
      dfs(step.id, [])
    }

    return cycles
  }

  /**
   * Detect missing dependencies
   */
  private detectMissingDependencies(workflow: Workflow): Array<{ stepId: string, dependency: string }> {
    const missing: Array<{ stepId: string, dependency: string }> = []
    const stepIds = new Set(workflow.steps.map(s => s.id))

    for (const step of workflow.steps) {
      if (step.dependencies) {
        for (const dep of step.dependencies) {
          if (!stepIds.has(dep)) {
            missing.push({ stepId: step.id, dependency: dep })
          }
        }
      }
    }

    return missing
  }

  /**
   * Check if command is safe
   */
  private isSafeCommand(command: string): boolean {
    const dangerous = ['rm -rf /', 'rm -rf /*', ':(){ :|:& };:', 'mkfs', 'dd if=/dev/zero']
    return !dangerous.some(pattern => command.includes(pattern))
  }

  /**
   * Check if command is valid
   */
  private isValidCommand(command: string, _context: ProjectContext): boolean {
    // Basic validation - check if command starts with a valid program
    const parts = command.trim().split(/\s+/)
    const cmd = parts[0]

    // Common valid commands
    const commonCommands = [
      'npm',
      'pnpm',
      'yarn',
      'bun',
      'git',
      'node',
      'python',
      'python3',
      'cargo',
      'go',
      'rustc',
      'javac',
      'java',
      'kotlin',
      'gcc',
      'clang',
      'make',
      'cmake',
      'docker',
      'podman',
      'ls',
      'cd',
      'mkdir',
      'cp',
      'mv',
      'echo',
      'cat',
      'grep',
      'find',
    ]

    return commonCommands.includes(cmd) || cmd.includes('/')
  }

  /**
   * Fix validation errors
   */
  private async fixValidationErrors(
    workflow: Workflow,
    validation: ValidationResult,
    context: ProjectContext,
    iteration = 0,
  ): Promise<Workflow> {
    if (iteration >= this.config.maxIterations!) {
      return workflow
    }

    const fixedWorkflow = { ...workflow }

    for (const error of validation.errors) {
      switch (error.type) {
        case 'missing_dependency':
          // Remove invalid dependency references
          if (error.stepId) {
            const step = fixedWorkflow.steps.find(s => s.id === error.stepId)
            if (step?.dependencies) {
              step.dependencies = step.dependencies.filter(d => d !== error.message?.split(': ')[1])
            }
          }
          break

        case 'circular_dependency':
          // Remove circular dependencies
          // This is a simplification - real implementation would be more sophisticated
          break

        default:
          // Other errors require manual intervention
          break
      }
    }

    return fixedWorkflow
  }

  /**
   * Optimize workflow
   */
  private optimize(workflow: Workflow): Workflow {
    // Calculate step levels for parallel execution
    const levels = this.calculateStepLevels(workflow)

    // Add level metadata to steps
    const optimizedSteps = workflow.steps.map(step => ({
      ...step,
      metadata: {
        ...step.metadata,
        level: levels.get(step.id) || 0,
      },
    }))

    return {
      ...workflow,
      steps: optimizedSteps,
      metadata: {
        ...workflow.metadata,
        estimatedDuration: this.estimateDuration(workflow),
      },
    }
  }

  /**
   * Calculate execution levels for steps (for parallelization)
   */
  private calculateStepLevels(workflow: Workflow): Map<string, number> {
    const levels = new Map<string, number>()
    const stepMap = new Map(workflow.steps.map(s => [s.id, s]))

    const calculateLevel = (stepId: string): number => {
      if (levels.has(stepId)) {
        return levels.get(stepId)!
      }

      const step = stepMap.get(stepId)
      if (!step || !step.dependencies || step.dependencies.length === 0) {
        levels.set(stepId, 0)
        return 0
      }

      const maxDepLevel = Math.max(
        0,
        ...step.dependencies.map(dep => calculateLevel(dep)),
      )

      levels.set(stepId, maxDepLevel + 1)
      return maxDepLevel + 1
    }

    for (const step of workflow.steps) {
      calculateLevel(step.id)
    }

    return levels
  }

  /**
   * Estimate workflow duration
   */
  private estimateDuration(workflow: Workflow): number {
    // Simple estimation based on step count and timeouts
    return workflow.steps.reduce((total, step) => {
      return total + (step.timeout || 300)
    }, 0) / 60 // Convert to minutes
  }

  /**
   * Calculate workflow complexity
   */
  private calculateComplexity(workflow: Workflow): 'simple' | 'medium' | 'complex' {
    const stepCount = workflow.steps.length

    if (stepCount <= 5) {
      return 'simple'
    }

    if (stepCount <= 15) {
      return 'medium'
    }

    return 'complex'
  }

  /**
   * Generate unique ID
   */
  private generateId(prefix: string): string {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * Get default validation for a step
   */
  private getDefaultValidation(step: WorkflowStep) {
    return {
      type: 'exit_code' as const,
      condition: '0',
      errorMessage: `Step ${step.name} failed`,
    }
  }

  /**
   * Get default error handling
   */
  private getDefaultErrorHandling() {
    return {
      strategy: 'abort' as const,
      maxAttempts: 1,
    }
  }
}
