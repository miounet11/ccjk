import { existsSync, mkdirSync, readFileSync } from 'node:fs'
import { exec } from 'tinyexec'
import { AIDER_CONFIG_FILE, AIDER_DIR, AIDER_ENV_FILE } from '../../constants'
import { writeFileAtomic } from '../fs-operations'

/**
 * Aider configuration
 */
export interface AiderConfig {
  // Model settings
  model?: string
  editFormat?: 'diff' | 'whole' | 'udiff'

  // API settings
  apiKey?: string
  apiBase?: string

  // Git settings
  autoCommits?: boolean
  dirtyCommits?: boolean

  // UI settings
  darkMode?: boolean
  prettyOutput?: boolean
  showDiffs?: boolean

  // Advanced settings
  mapTokens?: number
  maxChatHistory?: number
  cachePrompts?: boolean
}

/**
 * Default Aider configuration
 */
const DEFAULT_AIDER_CONFIG: AiderConfig = {
  model: 'claude-3-5-sonnet-20241022',
  editFormat: 'diff',
  autoCommits: true,
  dirtyCommits: false,
  darkMode: true,
  prettyOutput: true,
  showDiffs: true,
  mapTokens: 1024,
  maxChatHistory: 20,
  cachePrompts: true,
}

/**
 * Check if Aider is installed
 */
export async function isAiderInstalled(): Promise<boolean> {
  try {
    const result = await exec('aider', ['--version'])
    return result.exitCode === 0
  }
  catch {
    return false
  }
}

/**
 * Get Aider version
 */
export async function getAiderVersion(): Promise<string | null> {
  try {
    const result = await exec('aider', ['--version'])
    return result.stdout.trim()
  }
  catch {
    return null
  }
}

/**
 * Install Aider
 */
export async function installAider(): Promise<{ success: boolean, message: string }> {
  try {
    // Try pip install
    const result = await exec('pip', ['install', 'aider-chat'])

    if (result.exitCode === 0) {
      return { success: true, message: 'Aider installed successfully via pip' }
    }

    // Try pipx as fallback
    const pipxResult = await exec('pipx', ['install', 'aider-chat'])
    if (pipxResult.exitCode === 0) {
      return { success: true, message: 'Aider installed successfully via pipx' }
    }

    return { success: false, message: 'Failed to install Aider' }
  }
  catch (error) {
    return {
      success: false,
      message: `Failed to install Aider: ${error instanceof Error ? error.message : 'Unknown error'}`,
    }
  }
}

/**
 * Ensure Aider directory exists
 */
export function ensureAiderDir(): void {
  if (!existsSync(AIDER_DIR)) {
    mkdirSync(AIDER_DIR, { recursive: true })
  }
}

/**
 * Read Aider configuration
 */
export function readAiderConfig(): AiderConfig {
  if (!existsSync(AIDER_CONFIG_FILE)) {
    return DEFAULT_AIDER_CONFIG
  }

  try {
    const content = readFileSync(AIDER_CONFIG_FILE, 'utf-8')
    return parseYamlConfig(content)
  }
  catch {
    return DEFAULT_AIDER_CONFIG
  }
}

/**
 * Write Aider configuration
 */
export function writeAiderConfig(config: AiderConfig): void {
  ensureAiderDir()

  const yamlContent = generateYamlConfig(config)
  writeFileAtomic(AIDER_CONFIG_FILE, yamlContent)
}

/**
 * Parse YAML config (simple parser for Aider config)
 */
function parseYamlConfig(content: string): AiderConfig {
  const config: AiderConfig = {}
  const lines = content.split('\n')

  for (const line of lines) {
    const trimmed = line.trim()
    if (!trimmed || trimmed.startsWith('#'))
      continue

    const match = trimmed.match(/^(\w+):\s+(\S.*)$/)
    if (match) {
      const [, key, value] = match
      const normalizedKey = kebabToCamel(key)

      if (value === 'true')
        (config as any)[normalizedKey] = true
      else if (value === 'false')
        (config as any)[normalizedKey] = false
      else if (/^\d+$/.test(value))
        (config as any)[normalizedKey] = Number.parseInt(value)
      else
        (config as any)[normalizedKey] = value
    }
  }

  return config
}

/**
 * Generate YAML config
 */
function generateYamlConfig(config: AiderConfig): string {
  const lines: string[] = [
    '# Aider Configuration',
    '# Generated by CCJK',
    '',
  ]

  for (const [key, value] of Object.entries(config)) {
    if (value !== undefined) {
      const yamlKey = camelToKebab(key)
      lines.push(`${yamlKey}: ${value}`)
    }
  }

  return lines.join('\n')
}

/**
 * Convert kebab-case to camelCase
 */
function kebabToCamel(str: string): string {
  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())
}

/**
 * Convert camelCase to kebab-case
 */
function camelToKebab(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
}

/**
 * Configure Aider API
 */
export function configureAiderApi(apiKey: string, apiBase?: string): void {
  ensureAiderDir()

  const envLines: string[] = []

  // Determine API type based on key prefix
  if (apiKey.startsWith('sk-ant')) {
    envLines.push(`ANTHROPIC_API_KEY=${apiKey}`)
  }
  else if (apiKey.startsWith('sk-')) {
    envLines.push(`OPENAI_API_KEY=${apiKey}`)
  }
  else {
    // Generic API key
    envLines.push(`ANTHROPIC_API_KEY=${apiKey}`)
  }

  if (apiBase) {
    envLines.push(`OPENAI_API_BASE=${apiBase}`)
  }

  writeFileAtomic(AIDER_ENV_FILE, envLines.join('\n'))
}

/**
 * Get Aider model presets
 */
export function getAiderModelPresets(): Record<string, { model: string, description: string }> {
  return {
    'claude-sonnet': {
      model: 'claude-3-5-sonnet-20241022',
      description: 'Claude 3.5 Sonnet - Best for coding',
    },
    'claude-opus': {
      model: 'claude-3-opus-20240229',
      description: 'Claude 3 Opus - Most capable',
    },
    'gpt-4o': {
      model: 'gpt-4o',
      description: 'GPT-4o - OpenAI flagship',
    },
    'deepseek': {
      model: 'deepseek-chat',
      description: 'DeepSeek - Cost effective',
    },
    'gemini': {
      model: 'gemini-1.5-pro',
      description: 'Gemini 1.5 Pro - Google AI',
    },
  }
}

/**
 * Run Aider with options
 */
export async function runAider(options: {
  files?: string[]
  message?: string
  model?: string
  autoCommit?: boolean
}): Promise<{ success: boolean, output: string }> {
  const args: string[] = []

  if (options.model) {
    args.push('--model', options.model)
  }

  if (options.autoCommit === false) {
    args.push('--no-auto-commits')
  }

  if (options.message) {
    args.push('--message', options.message)
  }

  if (options.files && options.files.length > 0) {
    args.push(...options.files)
  }

  try {
    const result = await exec('aider', args)
    return {
      success: result.exitCode === 0,
      output: result.stdout + result.stderr,
    }
  }
  catch (error) {
    return {
      success: false,
      output: error instanceof Error ? error.message : 'Unknown error',
    }
  }
}
